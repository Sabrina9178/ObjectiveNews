# -*- coding: utf-8 -*-
"""TVBS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18MTRB4IKNz3_0rBUrBUA2lAOwkgrFjD_
"""

import datetime
from selenium.webdriver.edge.options import Options
from selenium import webdriver
from selenium.webdriver.common.by import By
import time
import csv
from tqdm import tqdm  # 加入進度條模組

import requests
from fake_useragent import UserAgent  # 使用 fake_useragent 生成隨機標頭
import random
from bs4 import BeautifulSoup

def get_news_content(url):
    # 隨機生成標頭
    user_agent = UserAgent()
    headers = {'User-Agent': user_agent.random}

    try:
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()  # 如果請求不成功，則拋出異常
        
        soup = BeautifulSoup(response.content, 'html.parser')
        title_elements = soup.find_all('h1', class_='title')  # 使用 class_ 來找到包含指定 class 的標籤
        news_title = title_elements[0].text if title_elements else ""  # 使用索引來獲取標題元素的文本

        time_element = soup.find('div',class_="author")
        for time in time_element.text.split('\t'):
            if "發佈時間" in time:
                news_time= time.split('：')[-1]
                news_time = datetime.datetime.strptime(news_time,'%Y/%m/%d %H:%M')
        content_elements = soup.find_all('div', id='news_detail_div')  # 使用 id 來找到指定 id 的標籤
        end_elements = soup.find_all('span',class_="endtext")
        for end_element in end_elements:
            end_element.decompose()
        img_elements = soup.find_all('img')
        for img_element in img_elements:
            img_element.decompose()
        ad_elements = soup.find_all('div',class_="guangxuan")
        for ad_element in ad_elements:
            ad_element.decompose()
        script_elements = soup.find_all('script')
        for script_element in script_elements:
            script_element.decompose()

        content_elements = soup.find_all('div', id='news_detail_div')  # 使用 id 來找到指定 id 的標籤 
        news_content = "\n".join([p.text for p in content_elements[0].find('body')]) if content_elements else ""  # 使用索引來獲取內容元素的文本
        return news_title, news_time, news_content
        
    except Exception as e:
        print(f"Failed to fetch news content: {e}")
        return "","",""

def find_TVBS_news(n_hours_ago,now,driver):

    # 新聞網站 URL
    url = "https://news.tvbs.com.tw/realtime"
    driver.get(url)

    # 找到所有含有 style 屬性的 li 元素
    li_elements = driver.find_elements(By.CSS_SELECTOR, "li[style]")

    # 將找到的元素的 style 屬性移除
    for li_element in li_elements:
#         driver.execute_script("arguments[0].removeAttribute('style')", li_element)
        driver.execute_script("arguments[0].remove", li_element)

    # 初始化一個空字典來存放新聞資訊
    news = {}
    index = 1
    
    # 初始化已抓取的新聞數量
    num_news_before_scroll = 0
    
    print("TVBS:")
    # 持續滾動頁面,直到找不到符合時間範圍的新聞為止
    while True:
        # 找到所有新聞項目
        news_items = driver.find_elements(By.CSS_SELECTOR, "div.news_list > div.list > ul > li:not([class])")
        # 如果沒有新的新聞項目,退出循環
        if not news_items:
            break

        # 標記本次循環是否找到了符合時間範圍的新聞
        found_new_news = False

        # 遍歷每個新聞項目
        for i in range(num_news_before_scroll, len(news_items)):
            item = news_items[i]
            # 獲取標題
            try:
                title_element = item.find_element(By.CSS_SELECTOR, "h2.txt")
                news_title = title_element.text if title_element else ""

                # 獲取相對時間
                time_element = item.find_element(By.CSS_SELECTOR, "div.time")
                relative_time_str = time_element.text if time_element else ""

                # 轉換相對時間為絕對時間
                absolute_time = convert_relative_time_to_absolute(relative_time_str,now)


            except:
                continue
            # 如果新聞時間在n秒範圍內
            if absolute_time >= n_hours_ago:
                
                # 獲取連結
                link_element = item.find_element(By.CSS_SELECTOR, "a")
                news_link = link_element.get_attribute('href') if title_element else ""
                # 獲取分類
                category_element = item.find_element(By.CSS_SELECTOR, "a > div.type")
                news_category = category_element.text if category_element else ""
                
                found_new_news = True

                # print(f"標題: {news_title}")
                # print(f"連結: {news_link}")
                # print(f"時間: {absolute_time}")
                # print(f"分類: {news_category}")
                # print("-------------------")

                news[index] = [news_title,
                               news_link,
                               absolute_time,
                               news_category]
                index += 1
            else:
                break
        
        num_news_before_scroll = len(news_items)
        
        # 如果本次循環中沒有找到符合時間範圍的新聞,就退出
        if not found_new_news:
            print(f"\n  stop date-time: {absolute_time}")
            break

        print(f"  found {len(news)} news, last date-time： {news[len(news)][2]}", end='\r')
        
        # 模擬滾動到頁面底部
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        driver.execute_script("window.scrollBy(0, -1);")
        time.sleep(1)  # 等待頁面響應

    # # 訪問每個新聞詳情頁,爬取內文
    # for index in tqdm(news, desc='Processing TVBS News'):
    #     driver.get(news[index][1])
    #     item = driver.find_elements(By.CSS_SELECTOR, "div.title_box")
    #     try:
    #         content_elements = driver.find_elements(By.CSS_SELECTOR, "div#news_detail_div")
    #         news_content = "\n".join([p.text for p in content_elements])
    #         news[index].append(news_content)
  
    #         title_element = item.find_element(By.CSS_SELECTOR, "h1.title")
    #         news_title = title_element.text if title_element else ""
            
    #     except:
    #         news[index].append("")
    
    print("\n")
    # 訪問每個新聞詳情頁,爬取內文
    
    
    return news

def convert_relative_time_to_absolute(relative_time_str,now):
    if "秒" in relative_time_str:
        seconds = int(relative_time_str.replace("秒前", ""))
        return now - datetime.timedelta(seconds=seconds)
    elif "分鐘" in relative_time_str:
        minutes = int(relative_time_str.replace("分鐘前", ""))
        return now - datetime.timedelta(minutes=minutes)
    elif "小時" in relative_time_str:
        hours = int(relative_time_str.replace("小時前", ""))
        return now - datetime.timedelta(hours=hours)
    elif "天" in relative_time_str:
        days = int(relative_time_str.replace("天前", ""))
        return now - datetime.timedelta(days=days)
    else:
        return now

